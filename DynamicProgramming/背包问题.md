#### 背包问题
##### 1. 01背包
&emsp;&emsp;01背包是其余背包问题的基础，问题形式十分简单，假设背包容量为`V`，现在有`N`件物品，第i个物品的体积为`c[i]`，价值为`w[i]`，要求选择不同的组合使得装进背包后的总价值最大。这里需要注意的是，每个物品只有一个，所以称其为01背包问题。
&emsp;&emsp;解决该问题的最朴素的想法是将所有的组合枚举出来，所有的组合个数有`2^n`个，这是指数级的，显然该问题是np问题。但是该问题存在动态规划解。这里以`c[] = {1,2,3,4}`,`w[] = {2,4,4,5}`为例。我们如果将问题规模放小一点，就是减少需要枚举的物品的数量，或者减少背包容量，则很容易将问题求出。当问题规模增大时，我们可以根据之前已经解决的问题来解决当前问题。具体地，当有新的物品加进来时，我们可以选择是否将该物品放入背包。
```cpp
dp[i][j] = max(dp[i-1][j],dp[i-1][j-c[i]] + w[i])
```
以上为01背包问题的动态规划方程，这里的状态有背包容量和物品数量两个，动作只有物品放入背包和不放入背包两个。如果物品不放入背包，那当前的物品数量状态与`i-1`一致，当前的背包容量与`j`一致。如果物品放入背包，当前的物品数量状态与`i-1`一致，但是背包容量将会变为`j-c[i]`。以下为01背包动态规划处理的主流程。
```cpp
 for (int i = 1; i <= n; ++i)
    {
        for (int j = 1; j <= v; ++j)
        {
            if (c[i] <= j)
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - c[i]] + w[i]);
            else
                dp[i][j] = dp[i - 1][j];
        }
    }
```
这里可以对以上解法进行优化，将原来的二维`dp[i][j]`优化为一维`dp[j]`。这里主要考虑到我们事实上只需要求出给定背包容量下的解，而不需要知道在不同物品数量下的解。
```cpp
dp[j] = max(dp[j], dp[j-c[i]]+ w[i])
```
注意，以上公式在迭代的时候与使用`dp[i][j]`相同，仅仅是用`dp[j]`来存储一些中间变量。
```cpp
   for (int i = 1; i <= n; ++i)
    {
        for (int j = v; j >= 0; --j)
        {
            if (j >= c[i])
                dp[j] = max(dp[j], dp[j - c[i]] + w[i]);
        }
    }
```
这里需要注意`j`是逆序进行的，原因为，当前的`dp[j]`的更新需要用到之前的数据，如果正序进行则会改变之前的数据，导致数据出错。
##### 2. 完全背包问题
&emsp;&emsp;相对于01背包问题，完全背包问题中的物品数量是无限的，可以装走该种物品的任意数量。其状态依然有两个，分别是，物品的种类数量和背包的容量。从动态规划的思想来考虑，将规模较大的问题分解成规模较小的问题，并探索大问题是如何依赖小问题的，从而找到递推关系。
```cpp
dp[i][j] = max(dp[i-1][j], dp[i][j-c[i]] + w[i])
```
这里动作依然只有两个，是否选择新种类的物品。如果不选择，状态退回到`dp[i-1][j]`，如果选择，状态退回到`dp[i][j-c[i]]`。这里特别需要注意`dp[i][j-c[i]]`与01背包的`dp[i-1][j-c[i]]`不同。其原因就在于物品可以重复选择。
```cpp
for (int i = 1; i <= n; ++i)
    {
        for (int j = 1; j <= v; ++j)
        {
            if (c[i] <= j)
                dp[i][j] = max(dp[i -1][j], dp[i][j - c[i]] + w[i]);
            else
                dp[i][j] = dp[i - 1][j];
        }
    }
```
与01背包一样，可以使用一维数组优化
```cpp
dp[j] = max(dp[j], dp[j-c[i]] + w[i])
```
具体代码为：
```cpp
for(int i = 1; i <= n; ++i)
{
    for(int j = 1; j <= v; ++j)
    {
        if(j >= c[i])
            dp[j] = max(dp[j], dp[j - c[i]] + w[i]);
    }
}
```
与优化后的01背包不同，完全背包的`j`并不是倒序的，原因为`dp[i][j]`依赖于`dp[i-1][j]`与`dp[i][j-c[i]]`，正序并不会导致这两个数据被更改。